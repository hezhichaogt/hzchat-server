/*
Package chat contains the core logic for handling real-time chat rooms, user connections, and message broadcasting.

This file defines the message structures, type constants, and utility functions used
for the WebSocket communication protocol between the server and clients.
*/
package chat

import (
	"encoding/json"
	"fmt"
	"time"

	"hzchat/internal/app/user"
	"hzchat/internal/pkg/logx"
	"hzchat/internal/pkg/randx"
)

// MessageType defines the type of a WebSocket message.
type MessageType string

const (
	// TypeInitData represents the initial data sent upon first connection
	// (current user, online list, max capacity).
	TypeInitData MessageType = "INIT_DATA"

	// TypeUserJoined represents a notification event for a new user joining the chat room.
	TypeUserJoined MessageType = "USER_JOINED"

	// TypeUserLeft represents a notification event for a user leaving the chat room.
	TypeUserLeft MessageType = "USER_LEFT"

	// TypeConfirm represents the server's acknowledgement (ACK) for a message sent by the client.
	TypeConfirm MessageType = "MSG_CONFIRM"

	// TypeText represents a standard text message sent by a user.
	TypeText MessageType = "TEXT"

	// TypeError represents a server-sent error notification.
	TypeError MessageType = "ERROR"
)

// InitDataPayload is the payload structure for a TypeInitData message.
type InitDataPayload struct {
	// CurrentUser is the identity information of the currently connecting user.
	CurrentUser user.User `json:"currentUser"`

	// OnlineUsers is the list of all currently online users in the chat room.
	OnlineUsers []user.User `json:"onlineUsers"`

	// MaxUsers is the maximum number of users allowed in this chat room.
	MaxUsers int `json:"maxUsers"`
}

// UserEventPayload is the payload structure for TypeUserJoined and TypeUserLeft messages.
type UserEventPayload struct {
	// User is the user involved in the join or leave event.
	User user.User `json:"user"`
}

// TextPayload is the payload structure for a TypeText message.
type TextPayload struct {
	// Content is the plain text content sent by the user.
	Content string `json:"content"`
}

// ErrorPayload is the payload structure for a TypeError message.
type ErrorPayload struct {
	// Code is the business error code.
	Code int `json:"code"`

	// Message is the user-friendly error description.
	Message string `json:"message"`
}

// RoomCleanupMsg is an internal message used for communication between goroutines
// within the Chat Manager, notifying that a specific chat room needs to be cleaned up and removed.
type RoomCleanupMsg struct {
	RoomCode string
}

// Message represents the standard message structure transmitted between the
// server and clients over WebSocket.
type Message struct {
	// ID is the globally unique message identifier generated by the server.
	ID string `json:"id"`

	// Type defines the purpose and content of the message (e.g., TEXT, ERROR, INIT_DATA).
	Type MessageType `json:"type"`

	// RoomCode is the code of the chat room this message belongs to or is sent to.
	RoomCode string `json:"room_code"`

	// Sender is the identity information of the user who sent the message.
	Sender user.User `json:"sender"`

	// Payload is the type-specific data structure, using json.RawMessage for deferred parsing.
	Payload json.RawMessage `json:"payload,omitempty"`

	// Timestamp is the time the message was created on the server (in UTC milliseconds).
	Timestamp int64 `json:"timestamp"`

	// TempID is the temporary ID carried by the client's message, returned unchanged
	// by the server upon message confirmation (ACK).
	TempID string `json:"tempID,omitempty"`
}

// NewMessage constructs and returns a new Message instance.
// It automatically generates the ID and timestamp, and marshals the payload struct
// into a JSON byte slice.
func NewMessage(msgType MessageType, roomCode string, sender user.User, payload any) (Message, error) {
	message := Message{
		ID:        randx.MessageID(),
		Timestamp: time.Now().UTC().UnixMilli(),
	}

	message.Type = msgType
	message.RoomCode = roomCode
	message.Sender = sender

	payloadBytes, err := json.Marshal(payload)
	if err != nil {
		logx.Error(
			err,
			"Failed to marshal message payload",
			"msg_type", string(msgType),
			"room_code", roomCode,
		)

		return Message{}, fmt.Errorf("failed to marshal payload for %s: %w", msgType, err)
	}

	message.Payload = payloadBytes

	return message, nil
}
